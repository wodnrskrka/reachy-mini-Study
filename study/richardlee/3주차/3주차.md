## **주요 기능_원형 궤적을 따라 머리를 움직이는 프로그램 작성**

1. draw_circle(): goto_target 사용, 부드러운 원형 이동    
- num_cycles: 반복 횟수
- radius: 반지름 (mm)
- speed: 각 포즈 간 이동 시간
- plane: 'xy', 'xz', 'yz' 선택
2. draw_circle_realtime(): set_target 사용, 실시간 추적
- 더 빠른 업데이트
- 지정 시간 동안 연속 실행
3. 평면 선택:
- 'xy': 수평 원 (좌우/앞뒤)
- 'xz': 수직 원 (앞뒤/위아래)
- 'yz': 수직 원 (좌우/위아래)

```python
import numpy as np
import time
from reachy_mini import ReachyMini
from reachy_mini.utils import create_head_pose

def draw_circle(mini, num_cycles=2, radius=20, speed=0.1, z_offset=0, plane='xy'):
    """
    원형 궤적으로 머리를 움직이는 함수
    
    Args:
        mini: ReachyMini 인스턴스
        num_cycles: 원을 몇 번 그릴지 (기본값: 2)
        radius: 원의 반지름 (밀리미터, 기본값: 20mm)
        speed: 각 포즈 간 이동 속도 (초, 기본값: 0.1초)
        z_offset: Z축 오프셋 (밀리미터, 기본값: 0)
        plane: 원을 그릴 평면 ('xy', 'xz', 'yz', 기본값: 'xy')
    """
    # 원형 궤적을 그리기 위한 점의 개수
    num_points = 50
    
    for cycle in range(num_cycles):
        print(f"원형 궤적 {cycle + 1}/{num_cycles} 시작...")
        
        for i in range(num_points):
            # 파라미터 t: 0부터 2π까지
            t = 2 * np.pi * i / num_points
            
            # 원형 패턴의 파라미터 방정식
            if plane == 'xy':
                # XY 평면 (수평 원)
                x = radius * np.cos(t)
                y = radius * np.sin(t)
                z = z_offset
            elif plane == 'xz':
                # XZ 평면 (수직 원, 앞뒤-위아래)
                x = radius * np.cos(t)
                y = 0
                z = radius * np.sin(t) + z_offset
            elif plane == 'yz':
                # YZ 평면 (수직 원, 좌우-위아래)
                x = 0
                y = radius * np.cos(t)
                z = radius * np.sin(t) + z_offset
            else:
                raise ValueError("plane은 'xy', 'xz', 'yz' 중 하나여야 합니다.")
            
            # 머리 포즈 생성 (밀리미터 단위)
            pose = create_head_pose(x=x, y=y, z=z, mm=True)
            
            # 목표 위치로 이동
            mini.goto_target(head=pose, duration=speed)
        
        print(f"원형 궤적 {cycle + 1}/{num_cycles} 완료")
    
    # 초기 위치로 복귀
    print("초기 위치로 복귀 중...")
    initial_pose = create_head_pose()
    mini.goto_target(head=initial_pose, duration=1.0)
    print("완료!")

# 실행 예시: XY 평면에서 원 그리기 (수평 원)
with ReachyMini() as mini:
    draw_circle(
        mini, 
        num_cycles=2,      # 2번 반복
        radius=20,         # 20mm 반지름
        speed=0.1,         # 각 포즈마다 0.1초
        z_offset=0,        # 높이 오프셋 없음
        plane='xy'         # XY 평면
    )
'''

## **중력 보상 모드에서 머리를 움직였을 때의 동작 분석**

### 1. 중력 보상이 필요한 이유

일반적으로 로봇의 모터 힘을 완전히 빼버리면(`disable_motors`), 로봇은 쇳덩어리나 플라스틱 덩어리에 불과하므로 중력에 의해 바닥으로 툭 떨어집니다. 하지만 중력 보상 모드가 작동하면 다음과 같은 차이가 생깁니다.

- **손으로 직접 가르치기(Lead-through Teaching):** 사람이 로봇 팔을 잡고 움직일 때, 로봇의 무게가 느껴지지 않아 아주 가볍고 부드럽게 원하는 위치로 옮길 수 있습니다.
- **안전(Safety):** 로봇이 사람이나 장애물과 부딪혔을 때, 딱딱하게 저항하지 않고 충격 방향으로 부드럽게 밀려나므로 사고를 예방할 수 있습니다.
- **제어 효율성:** 로봇이 특정 동작을 수행할 때, 이미 중력을 이겨내고 있는 상태에서 시작하므로 더 정밀하고 부드러운 움직임이 가능합니다.

| **구분** | **모터 OFF (Disabled)** | **중력 보상 (Gravity Comp.)** | **위치 제어 (Stiff/PID)** |
| --- | --- | --- | --- |
| **상태** | 힘이 완전히 빠짐 | **자신의 무게만 지탱함** | 지정된 각도를 꽉 유지함 |
| **움직임** | 중력 때문에 아래로 추락 | **사람이 밀면 민 대로 멈춰 있음** | 사람이 밀어도 꿈쩍도 안 함 |
| **느낌** | 흐물흐물한 인형 | **무중력 상태의 물체** | 딱딱한 기계 |
